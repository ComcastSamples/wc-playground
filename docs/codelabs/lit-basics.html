    <!doctype html>

    <html>
    <head>
      <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
      <meta name="theme-color" content="#4F7DC9">
      <meta charset="UTF-8">
      <title>open-wc codelab | lit-html & lit-element: basics</title>
      <meta name="robots" content="noindex">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
      <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
      <style>
        .success {
          color: #1e8e3e;
        }
        .error {
          color: red;
        }
      </style>
    </head>

    <body>
      <google-codelab title="lit-html & lit-element: basics" feedback-link="https://github.com/ComcastSamples/wc-playground/issues">


    <google-codelab-step label="Introduction">

    <p>In this codelab, you will learn the basics of building web components using lit-html and lit-element.</p>

    <aside class="notice">
      This is a copy of the excellent Codelab created by the Open Web Components team at
      <a href="https://open-wc.org/guides/developing-components/codelabs/">https://open-wc.org/guides/developing-components/codelabs/</a> with a few slight modifications for an in-person workshop. You should only use this instance if you are in our workshop. Otherwise, please use the original source.
    </aside>

    <p><a href="https://lit.dev/docs/libraries/standalone-templates/">lit-html</a> is an efficient, expressive and extensible HTML templating library for JavaScript. It lets you write HTML templates in JavaScript, then efficiently render and re-render those templates together with data to create and update DOM:</p><p><a href="https://lit.dev/docs/api/LitElement/">lit-element</a> is a simple base class for creating fast and lightweight web components with lit-html.</p><p><strong>What you need</strong></p><ul>
<li>A web browser that supports Web Components: Firefox, Safari, Chrome or any Chromium-based browser.</li>
<li>Intermediate knowledge of HTML and Javascript</li>
<li>Basic knowledge of web components, see our <a href="https://open-wc.org/codelabs/#web-components-basics">basics codelab</a> to get you started.</li>
<li>Familiarity with the following concepts:<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">Javascript Modules</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">Array filter</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array map</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Object &amp; array spread</a></li>
</ul>
</li>
</ul><p><strong>What you'll learn</strong></p><ul>
<li>Creating web components with lit-element</li>
<li>Templating with lit-html</li>
<li>Repeating templates</li>
<li>Conditional rendering</li>
<li>Handling events</li>
<li>Managing data</li>
<li>Creating child components</li>
</ul><p><strong>How it works</strong></p><p>This codelab will go step by step, explaining each code change. At the bottom of each section there is a "View final result" button, this will show you the correct code that you should end up with, incase you get stuck. The steps are sequential, thus results from the previous steps carry over to the next step.</p>

    </google-codelab-step>

    <google-codelab-step label="Setup">

    <p>In this codelab, we will build a simple todo app. This is a great exercise for learn the basics of lit-html and lit-element.</p><p>You can follow this codelab using anything that is able to display a simple HTML page. We recommend using an <a href="https://jsbin.com/?html,output">online code editor like jsbin</a>, but you can also create your own html page in your favorite IDE.</p><p>To get started, let's create a basic HTML page:</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    My todo app
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>If you run this in the browser and see '<em>My todo app</em>' on the screen, you're good to go.</p>

    </google-codelab-step>

    <google-codelab-step label="lit-element setup">

    <p><a href="https://github.com/lit/lit/tree/main/packages/lit-element">lit-element</a> takes care of most of the boilerplating when creating components. This provides a great developer experience while staying close to the browser platform and does not require any build steps to run in the browser. It's a mere 5kb in size which makes it an ideal lightweight choice.</p><p><a href="https://github.com/lit/lit/tree/main/packages/lit-element">lit-element</a> is written and distributed as an ES module. This means that we can import it using the browser's native module loader. Let's create a module script and import LitElement from our local node_modules:</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;

&lt;html&gt;
  &lt;body&gt;
    &lt;script type="module"&gt;
      import { LitElement } from 'lit';
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Make sure that you add <code>type="module"</code> to the script tag.</p><aside class="notice">
For this to work, you should have installed dependencies via <code>npm install</code> and started your local server via <code>npm start</code>.
</aside><p>Next, we need to define our web component. When writing a vanilla web component we extend from the native <code>HTMLElement</code> class that is already in your browser. With lit-element we need to import and extend from the <code>LitElement</code> class which, in turn, extends from the <code>HTMLElement</code> class.</p><pre><code class="language-js">class TodoApp extends LitElement {
  connectedCallback() {
    super.connectedCallback();
    console.log('lit element connected');
  }
}

customElements.define('todo-app', TodoApp);</code></pre><p>We defined the tag name for our element as <code>todo-app</code>, now we need to add this to the HTML of our page:</p><pre><code class="language-html">&lt;todo-app&gt;&lt;/todo-app&gt;</code></pre><p>If you run this in the browser you should see <code>lit element connected</code> logged to the terminal.</p><aside class="notice">
  Because the LitElement class also does some work in the `connectedCallback` method, we should always call `super.connectedCallback()`. This is a common source of bugs and confusion, so make sure to remember this!
</aside><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement } from 'lit';

      class TodoApp extends LitElement {
        connectedCallback() {
          super.connectedCallback();
          console.log('lit element connected');
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Hello world">

    <p>Now that we defined our element we can start adding a template. lit-element uses lit-html to handle the templating. lit-html works by writing HTML inside of template literals. Template literals are a type of strings which can span multiple lines, ideal for writing HTML:</p><pre><code class="language-js">const template = `
  &lt;h1&gt;Hello world&lt;/h1&gt;
`;</code></pre><p>In order to create an actual lit-html template, we need to prefix the template literal with a special HTML tag:</p><pre><code class="language-js">import { html } from 'lit';

const template = html` &lt;h1&gt;Hello world&lt;/h1&gt; `;</code></pre><p>This is a native browser feature called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates">tagged template literals</a>. The <code>html</code> tag is just a function that gets called with information about the template literal that it's attached to. We won't go into details of how it works exactly. By using this syntax, lit-html can very efficiently create templates and update only the parts that changed when re-rendering.</p><aside class="notice">
  Most popular IDEs support syntax highlighting of HTML inside template literals, but for some you might need to install a plugin. <a href="https://open-wc.org/guides/tools/ide/">See our IDE section</a> to learn more about that.
</aside><p>lit-element has a <code>render()</code> function. The element calls the function on each update and expects a template from it to render.</p><p>Let's start by displaying the title of our app:</p><pre><code class="language-js">render() {
  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;
  `;
}</code></pre><p>If you refresh the browser, you should see the title displayed on the page.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      class TodoApp extends LitElement {
        render() {
          return html` &lt;h1&gt;Todo app&lt;/h1&gt; `;
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Templating basics">

    <p>Templates are just javascript variables. We can also create them outside of our component's context. A good example of this is when you want to share pieces of a template between different components.</p><p>Let's add a footer to our application. First, let's create the template for the footer:</p><pre><code class="language-js">const footerTemplate = html`
  &lt;footer&gt;Made with love by &lt;a href="https://open-wc.org/"&gt;open-wc&lt;/a&gt;&lt;/footer&gt;
`;</code></pre><p>You can add your own name and website in there as author.</p><p>Template literals can contain placeholders. These are indicated by a dollar sign with curly braces: <code>${expression}</code>.</p><aside class="notice">
  Template literals are often used when building error messages:

<pre><code class="language-js">// regular string
console.error('An error occurred: ' + message);
// template literal
console.error(`An error occurred: ${message}`);</code></pre>
</aside><p>lit-html takes advantage of this feature in order to compose templates and to create dynamic parts inside your templates. For example, we can add the footer to our app's template by simply embedding it:</p><pre><code class="language-js">class TodoApp extends LitElement {
  render() {
    return html`
      &lt;h1&gt;Todo app&lt;/h1&gt;

      ${footerTemplate}
    `;
  }
}</code></pre><p>You should now see both the app's title and footer on the page.</p><p>lit-html supports embedding different types of variables. In the example above, we embedded a template inside of another template, but we can also embed strings inside of a template. Let's extract the link text to a separate variable and then embed it in the template:</p><pre><code class="language-js">const author = 'open-wc';
const footerTemplate = html`
  &lt;footer&gt;Made with love by &lt;a href="https://open-wc.org/"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
`;</code></pre><p>We can also extract the link to a separate variable, and set the href attribute with a variable:</p><pre><code class="language-js">const author = 'open-wc';
const homepage = 'https://open-wc.org/';
const footerTemplate = html`
  &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
`;</code></pre><p>When embedding variables like this, lit-html remembers which parts of your template are static and which parts are dynamic. When re-rendering the same template you can change the value of these variables and lit-html will know to only update the parts that changed. This makes it very efficient!</p><aside class="notice">
It's important to keep in mind that whatever you're writing must still be valid HTML and you cannot arbitrarily concatenate strings to build HTML. This is important to enable efficient updates, as well as for security to protect you from XSS attacks.

<p>For example you cannot set tagnames or attribute keys dynamically:</p>
<pre><code class="language-js">const attributes = `href="https://open-wc.org/"`;
const tagname = 'footer';
// this does not work
const footerTemplate = html`
  &lt;${tagname}&gt;
    Made with love by &lt;a ${attributes}&gt;&lt;/a&gt;
  &lt;/${tagname}&gt;
`;</code></pre>
</aside><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            ${footerTemplate}
          `;
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Displaying todos">

    <p>Now that you know how to compose templates with lit-html, we can start adding a list of todos to our application.</p><p>Let's start by creating an array of todos in the constructor of our component:</p><pre><code class="language-js">class TodoApp extends LitElement {
  constructor() {
    super();
    this.todos = ['Do A', 'Do B', 'Do C'];
  }
}</code></pre><p>We can render this array directly inside the template of our application:</p><pre><code class="language-js">render() {
  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;

    ${this.todos} ${footerTemplate}
  `;
}</code></pre><p>When you pass an array to lit-html, it will just iterate and render what's inside it. In this case, it will render the list of todos as plain text.</p><p>Just displaying text is not what we want though, we need something more complex. This is where we can combine two capabilities of lit-html: iterating arrays and rendering nested templates. If we turn our array of strings to an array of templates, we can render HTML for each of our todos.</p><p>A great way to accomplish this is through a map function. Let's create an ordered list of todos:</p><pre><code class="language-js">render() {
  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;

    &lt;ol&gt;
      ${this.todos.map(
        todo =&gt; html`
          &lt;li&gt;${todo}&lt;/li&gt;
        `,
      )}
    &lt;/ol&gt;

    ${footerTemplate}
  `;
}</code></pre><p>Apart from displaying the text of a todo item, we need to indicate whether the todo item is finished or not.</p><p>Let's update our data structure from strings to objects and display the finished state on the screen:</p><pre><code class="language-js">this.todos = [
  { text: 'Do A', finished: true },
  { text: 'Do B', finished: false },
  { text: 'Do C', finished: false },
];</code></pre><pre><code class="language-js">render() {
  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;

    &lt;ol&gt;
      ${this.todos.map(
        todo =&gt; html`
          &lt;li&gt;${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})&lt;/li&gt;
        `,
      )}
    &lt;/ol&gt;

    ${footerTemplate}
  `;
}</code></pre><p>Because template literals allow us to place any expression inside of the curly braces, we can use ternary operators for quick and easy conditional logic.</p><p>You should now see three todo items on the screen, where the first one is already finished.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})&lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            ${footerTemplate}
          `;
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Adding a todo">

    <p>Now, we will add the ability to add todos to our list.</p><p>Start by adding an input field and a button:</p><pre><code class="language-html">&lt;h1&gt;Todo app&lt;/h1&gt;

&lt;input id="addTodoInput" placeholder="Name" /&gt;
&lt;button @click="${this._addTodo}"&gt;Add&lt;/button&gt;

&lt;ol&gt;
  ...
&lt;/ol&gt;</code></pre><p>On the "add" button we attached an event listener that listens for the <code>click</code> event. This is done by prefixing the event name with a <code>@</code> and attributing a function to it.</p><pre><code class="language-js">html` &lt;button @click=${this._addTodo}&gt;&lt;/button&gt; `;</code></pre><p>This is just syntactic sugar that executes the <code>addEventListener()</code> function on the element with the specified event and function. In this case, we reference a function of our component, which we should now implement:</p><pre><code class="language-js">_addTodo() {
  const input = this.shadowRoot.getElementById('addTodoInput');
  const text = input.value;
  input.value = '';

  this.todos.push({ text, finished: false });
  this.requestUpdate();
}</code></pre><p>When this event handler is called, we create a new todo item and add it to the array of todos. Next we need to trigger a re-render so that we can display the new todo item on the screen. We can do this by calling the <code>requestUpdate</code> method which exists on any element that extends from the <code>LitElement</code> class.</p><p>When you click add, you should see the new element appear on the screen.</p><p>This allows us to observe the awesome power of lit-html in action. If you inspect the DOM while adding a new todo item, you will notice that only the new todo item is flashing.</p><p>When something in the DOM inspector flashes, it means that the browser is doing actual work to update the DOM tree. This is very expensive, things like the styles and layout need to be recalculated up and down the element tree, so it is wise to minimize this as much as possible. lit-html knows exactly what changed where and it will update only that part, making it super efficient.</p><aside class="notice">
In the inspector you also see comment nodes between different parts of your template. These are markers created by lit-html to track the locations of DOM nodes, they can be ignored safely.
</aside><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})&lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos.push({ text, finished: false });
          this.requestUpdate();
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Reactive property changes">

    <p>Right now, we're triggering updates manually whenever we make a change. This is fine for some use cases, but it can get pretty cumbersome and we are not able to respond to changes triggered by parent components.</p><p>It's better to let <code>LitElement</code> observe data changes for us and, trigger updates when necessary. We can do this by defining <code>todos</code> as a property of our element.</p><p>Start by adding a static properties field, and add <code>todos</code> as an array property:</p><pre><code class="language-js">static get properties() {
  return {
    todos: { type: Array }
  };
}</code></pre><p>For each property that you've defined, <code>LitElement</code> generates something similar to this:</p><pre><code class="language-js">class TodosApp extends LitElement {
  set todos(newTodos) {
    if (this._todos === newTodos) {
      // no change, don't do any work
      return;
    }

    // value changed, trigger an update
    this._todos = newTodos;
    this.requestUpdate();
  }

  get todos() {
    return this._todos;
  }
}</code></pre><p>This way when you change the property on your element, it goes through a custom getter/setter function which triggers an update only when the new value passes a simple equality check.</p><p>For strings, numbers and booleans this will work without any problems. However, if you are using arrays or objects and mutate them, it will not trigger any update. This is because the actual array or object itself did not change. We need to use immutable data patterns, where a new object is created for each change. This is a common pattern in front-end to simplify data flow and make change detection easier.</p><p>In our case we are using Array's <code>push()</code> function, which mutates the existing <code>this.todos</code> array. In order to use an immutable data pattern, instead, we can copy the existing list of todos using array spread, add our new todo and assign it back to <code>this.todos</code>:</p><pre><code class="language-js">_addTodo() {
  const input = this.shadowRoot.getElementById('addTodoInput');
  const text = input.value;
  input.value = '';

  this.todos = [
    ...this.todos,
    { text, finished: false },
  ];
}</code></pre><p>The list should now still update like before.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})&lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Deleting a todo">

    <p>If we make a mistake, we want to be able to remove a todo item from the list.</p><p>Let's add a delete button to the template of a todo item:</p><pre><code class="language-html">&lt;ol&gt;
  ${this.todos.map(
    todo =&gt; html`
      &lt;li&gt;
        ${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})
        &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
      &lt;/li&gt;
    `,
  )}
&lt;/ol&gt;</code></pre><p>We need to pass along the item we want to delete to the event handler, so instead of referencing the method directly we are using an arrow function and we call it with the item of the current iteration of our map function.</p><p>Next, we add the event handler which deletes the todo item:</p><pre><code class="language-js">_removeTodo(todo) {
  this.todos = this.todos.filter(e =&gt; e !== todo);
}</code></pre><p>The delete button should now be fully functional. In this function as well, we assign a new array to <code>this.todos</code> as <code>filter()</code> returns a new array. <code>LitElement</code> will automatically detect the new array and re-render our component.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    ${todo.text} (${todo.finished ? 'Finished' : 'Unfinished'})
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }

        _removeTodo(todo) {
          this.todos = this.todos.filter(e =&gt; e !== todo);
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Finishing a todo">

    <p>A todo list is useless if we can't keep track of which todos we've finished, and which todos we have not. What we need is a way to manage its state.</p><p>First, let's replace our finished/unfinished text with a checkbox:</p><pre><code class="language-html">  &lt;li&gt;
    &lt;input
      type="checkbox"
      .checked=${todo.finished}
      @change=${e =&gt; this._changeTodoFinished(e, todo)}
    /&gt;
    ${todo.text}
    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
  &lt;/li&gt;</code></pre><p>Notice that we prefixed the <code>checked</code> attribute on the checkbox with a <code>.</code>. This is special lit-html syntax to specifiy we want to set the property named <code>checked</code> instead of the attribute named <code>checked</code>.</p><aside class="notice">
Attributes are how we can assign (string) data in the HTML representation of an element:

<pre><code class="language-html">&lt;input value="foo" /&gt;</code></pre>
<p>Properties are how we can assign data in javascript, on the actual DOM element in Javascript:</p>
<pre><code class="language-js">const input = /* get a reference to the input element */;
input.value = 'foo';</code></pre>
<p>We can also access or set attribute data in Javascript.</p>
<pre><code class="language-js">const input = /* get a reference to the input element */;
input.setAttribute('value', 'foo');</code></pre>
<p>The concept of attributes and properties of a HTML element confuses a lot of people, as it is sometimes thought to represent the same data and to be interchangeable. It's up to each element on how (and if) to keep the value of properties and attributes in sync. A common practice is to sync changes to an attribute to a property of the same name but not to reflect changes to properties to an attribute of the same name.</p>
</aside><p>We're listening to the input's <code>change</code> event to update our data when the checkbox value is changed. Besides the todo object, we are also passing along the event object itself. We need this to be able to get the value of the checkbox.</p><p>In the event handler, we can use the <code>map()</code> function to update the finished property of our todo:</p><pre><code class="language-js">_changeTodoFinished(e, changedTodo) {
  const finished = e.target.checked;

  this.todos = this.todos.map((todo) =&gt; {
    if (todo !== changedTodo) {
      return todo;
    }
    return { ...changedTodo, finished };
  });
}</code></pre><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    &lt;input
                      type="checkbox"
                      .checked=${todo.finished}
                      @change=${e =&gt; this._changeTodoFinished(e, todo)}
                    /&gt;
                    ${todo.text}
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }

        _removeTodo(todo) {
          this.todos = this.todos.filter(e =&gt; e !== todo);
        }

        _changeTodoFinished(e, changedTodo) {
          const finished = e.target.checked;

          this.todos = this.todos.map(todo =&gt; {
            if (todo !== changedTodo) {
              return todo;
            }
            return { ...changedTodo, finished };
          });
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Displaying totals">

    <p>Now that we can manage our todo items, it's pretty easy to display some more information about our list. For example, we can add the total amount of finished and unfinished items.</p><p>These are not new sources of data, but rather a simple calculation based on existing data. We could do these calculations inline in our template where we want to display them, but this can get messy, pretty quickly.</p><p>Good practice is to use the top of your render function as a place to prepare variables with some meaningful names to use them in your template. This provides the best readability.</p><p>Let's add our calculations to the render function, and display the calculated amounts in the template:</p><pre><code class="language-js">render() {
  const finishedCount = this.todos.filter(e =&gt; e.finished).length;
  const unfinishedCount = this.todos.length - finishedCount;

  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;

    &lt;input id="addTodoInput" placeholder="Name" /&gt;
    &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

    &lt;ol&gt;
    ...
    &lt;/ol&gt;

    &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
    &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

    ${footerTemplate}
  `;
}</code></pre><p>Remember that the <code>render()</code> function can be called quite often. If the computations are expensive, it's better to only do them once and cache the results.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          const finishedCount = this.todos.filter(e =&gt; e.finished).length;
          const unfinishedCount = this.todos.length - finishedCount;

          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    &lt;input
                      type="checkbox"
                      .checked=${todo.finished}
                      @change=${e =&gt; this._changeTodoFinished(e, todo)}
                    /&gt;
                    ${todo.text}
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
            &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }

        _removeTodo(todo) {
          this.todos = this.todos.filter(e =&gt; e !== todo);
        }

        _changeTodoFinished(e, changedTodo) {
          const finished = e.target.checked;

          this.todos = this.todos.map(todo =&gt; {
            if (todo !== changedTodo) {
              return todo;
            }
            return { ...changedTodo, finished };
          });
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Create a child component">

    <p>It looks like we're feature complete! We can display a list of todos, add or remove them and check them off once completed.</p><p>However, we've been putting everything inside only one component, and it's starting to get crowded. It's better to split functionality up into separate components. We are building Web Components, after all.</p><p>The todo list is an ideal candidate to be moved into a separate component. Let's go ahead and define the basic structure of our element. If you're working in an online editor, it's probably easier to do this in the same file. If you're using a local editor, it's best to create a separate file for this.</p><p>If you use a separate file, don't forget to import <code>LitElement</code> and <code>html</code> for that module as well.</p><pre><code class="language-js">class TodoList extends LitElement {
  static get properties() {
    return {
      todos: { type: Array },
    };
  }

  render() {
    if (!this.todos) {
      return html``;
    }

    return html`
      &lt;ol&gt;
        ${this.todos.map(
          todo =&gt; html`
            &lt;li&gt;
              &lt;input
                type="checkbox"
                .checked=${todo.finished}
                @change=${e =&gt; this._changeTodoFinished(e, todo)}
              /&gt;
              ${todo.text}
              &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
            &lt;/li&gt;
          `,
        )}
      &lt;/ol&gt;
    `;
  }
}

customElements.define('todo-list', TodoList);</code></pre><p>The structure of the class should be pretty familiar by now. It has a <code>todos</code> property and a template to render. The <code>render()</code> function looks similar as before, except that there is an <code>if</code> condition now at the top of the function. We need this because, unlike before, our todo list is not in charge of the data anymore.</p><p>The parent element is still in charge, and we expect that it will pass along the todos list to this component. This means that we can't assume that the list will always be there when rendered. If we don't take care of this, our component will crash because you can't run a <code>map</code> function on <code>undefined</code>. Adding an early return to the render function is a simple way to do this. It makes it easy to see which properties are required for rendering.</p><p>Next, we need to somehow let the parent element know that the user clicked on the checkbox or the remove button. We can do this by using DOM events. DOM events are great because the structure and hierarchy of our application is reflected in the DOM. When an event gets fired on a component, only parent components up the DOM tree can receive it. This behavior allows our communication system to be automatically scoped.</p><p>Let's add the events that we want to fire:</p><pre><code class="language-js">_changeTodoFinished(e, changedTodo) {
  const eventDetails = { changedTodo, finished: e.target.checked };
  this.dispatchEvent(new CustomEvent('change-todo-finished', { detail: eventDetails }));
}

_removeTodo(item) {
  this.dispatchEvent(new CustomEvent('remove-todo', { detail: item }));
}</code></pre><p>The next step will be to actually use the new child component. We will need to pass on the appropriate data and listen to the events fired by the child.</p><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html } from 'lit';

      class TodoList extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        render() {
          if (!this.todos) {
            return html``;
          }

          return html`
            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    &lt;input
                      type="checkbox"
                      .checked=${todo.finished}
                      @change=${e =&gt; this._changeTodoFinished(e, todo)}
                    /&gt;
                    ${todo.text}
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;
          `;
        }

        _changeTodoFinished(e, changedTodo) {
          const eventDetails = { changedTodo, finished: e.target.checked };
          this.dispatchEvent(new CustomEvent('change-todo-finished', { detail: eventDetails }));
        }

        _removeTodo(item) {
          this.dispatchEvent(new CustomEvent('remove-todo', { detail: item }));
        }
      }

      customElements.define('todo-list', TodoList);

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          const finishedCount = this.todos.filter(e =&gt; e.finished).length;
          const unfinishedCount = this.todos.length - finishedCount;

          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    &lt;input
                      type="checkbox"
                      .checked=${todo.finished}
                      @change=${e =&gt; this._changeTodoFinished(e, todo)}
                    /&gt;
                    ${todo.text}
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;

            &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
            &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }

        _removeTodo(todo) {
          this.todos = this.todos.filter(e =&gt; e !== todo);
        }

        _changeTodoFinished(e, changedTodo) {
          const finished = e.target.checked;

          this.todos = this.todos.map(todo =&gt; {
            if (todo !== changedTodo) {
              return todo;
            }
            return { ...changedTodo, finished };
          });
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Implement a child element">

    <p>Now that we've created our child element, we need to implement it in the parent element. If you created your child element in a separate file, you will need to import it in the parent element:</p><pre><code class="language-js">import './todos-list.js';</code></pre><p>Some online editors automatically include separate files.</p><p>To render our child component, we simply replace the existing template with the tag of the child component:</p><pre><code class="language-js">render() {
  const finishedCount = this.todos.filter(e =&gt; e.finished).length;
  const unfinishedCount = this.todos.length - finishedCount;

  return html`
    &lt;h1&gt;Todo app&lt;/h1&gt;

    &lt;input id="addTodoInput" placeholder="Name" /&gt;
    &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

    &lt;todo-list .todos=${this.todos}&gt;&lt;/todo-list&gt;

    &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
    &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

    ${footerTemplate}
  `;
}</code></pre><p>If you refresh, the UI should remain unchanged. If that is the case, congratulations! You're now composing elements like a pro. :)</p><p>Notice that we are again using the property syntax to pass on the data in <code>this.todo</code> to the <code>&lt;todo-list&gt;</code> element.</p><p>Next, we need to listen to the new events of <code>&lt;todo-list&gt;</code>:</p><pre><code class="language-html">&lt;todo-list
  .todos="${this.todos}"
  @change-todo-finished="${this._changeTodoFinished}"
  @remove-todo="${this._removeTodo}"
&gt;&lt;/todo-list&gt;</code></pre><p>The events are calling the existing methods that we already have defined in our element. However, we will need to update the event handlers slightly to handle these new events:</p><pre><code class="language-js">_removeTodo(e) {
  this.todos = this.todos.filter(todo =&gt; todo !== e.detail);
}

_changeTodoFinished(e) {
  const { changedTodo, finished } = e.detail;

  this.todos = this.todos.map((todo) =&gt; {
    if (todo !== changedTodo) {
      return todo;
    }
    return { ...changedTodo, finished };
  });
}</code></pre><p>After this, your application should work just like before, but the code is not as spread out anymore.</p><details>
  <summary>View final result</summary>

  <pre><code class="language-html">&lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;body&gt;
        &lt;todo-app&gt;&lt;/todo-app&gt;

        &lt;script type="module"&gt;
          import { LitElement, html } from 'lit';

          class TodoList extends LitElement {
            static get properties() {
              return {
                todos: { type: Array },
              };
            }

            render() {
              if (!this.todos) {
                return html``;
              }

              return html`
                &lt;ol&gt;
                  ${this.todos.map(
                    todo =&gt; html`
                      &lt;li&gt;
                        &lt;input
                          type="checkbox"
                          .checked=${todo.finished}
                          @change=${e =&gt; this._changeTodoFinished(e, todo)}
                        /&gt;
                        ${todo.text}
                        &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                      &lt;/li&gt;
                    `,
                  )}
                &lt;/ol&gt;
              `;
            }

            _changeTodoFinished(e, changedTodo) {
              const eventDetails = { changedTodo, finished: e.target.checked };
              this.dispatchEvent(new CustomEvent('change-todo-finished', { detail: eventDetails }));
            }

            _removeTodo(item) {
              this.dispatchEvent(new CustomEvent('remove-todo', { detail: item }));
            }
          }

          customElements.define('todo-list', TodoList);

          const author = 'open-wc';
          const homepage = 'https://open-wc.org/';
          const footerTemplate = html`
            &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
          `;

          class TodoApp extends LitElement {
            static get properties() {
              return {
                todos: { type: Array },
              };
            }

            constructor() {
              super();
              this.todos = [
                { text: 'Do A', finished: true },
                { text: 'Do B', finished: false },
                { text: 'Do C', finished: false },
              ];
            }

            render() {
              const finishedCount = this.todos.filter(e =&gt; e.finished).length;
              const unfinishedCount = this.todos.length - finishedCount;

              return html`
                &lt;h1&gt;Todo app&lt;/h1&gt;

                &lt;input id="addTodoInput" placeholder="Name" /&gt;
                &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

                &lt;todo-list
                  .todos="${this.todos}"
                  @change-todo-finished="${this._changeTodoFinished}"
                  @remove-todo="${this._removeTodo}"
                &gt;&lt;/todo-list&gt;

                &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
                &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

                ${footerTemplate}
              `;
            }

            _addTodo() {
              const input = this.shadowRoot.getElementById('addTodoInput');
              const text = input.value;
              input.value = '';

              this.todos = [...this.todos, { text, finished: false }];
            }

            _removeTodo(e) {
              this.todos = this.todos.filter(todo =&gt; todo !== e.detail);
            }

            _changeTodoFinished(e) {
              const { changedTodo, finished } = e.detail;

              this.todos = this.todos.map(todo =&gt; {
                if (todo !== changedTodo) {
                  return todo;
                }
                return { ...changedTodo, finished };
              });
            }
          }

          customElements.define('todo-app', TodoApp);
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Styling">

    <p>We've covered the basics of templating and managing data with lit-element. The last remaining topic we need to look into is styling. This isn't a codelab on CSS, so we will only look at some of the specifics of working with styling in lit-element.</p><p>For styling, lit-element uses Shadow DOM. If you're not familiar with Shadow DOM, I recommend following the <a href="https://open-wc.org/codelabs/basics/web-components.html">web component basics</a> codelab.</p><p>To define the styles of your element we need to import the <code>css</code> tag and add a static styles property on our element. Let's add styles to the todo list:</p><pre><code class="language-js">import { LitElement, html, css } from 'lit';

class TodoList extends LitElement {
  static get properties() {
    return {
      todos: { type: Array },
    };
  }

  static get styles() {
    return css`
      :host {
        color: blue;
      }

      ul {
        list-style: none;
        padding: 0;
      }

      button {
        background-color: transparent;
        border: none;
      }
    `;
  }

  render() {
    if (!this.todos) {
      return html``;
    }

    return html`
      &lt;ol&gt;
        ${this.todos.map(
          todo =&gt; html`
            &lt;li&gt;
              &lt;input
                type="checkbox"
                .checked=${todo.finished}
                @change=${e =&gt; this._changeTodoFinished(e, todo)}
              /&gt;
              ${todo.text}
              &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
            &lt;/li&gt;
          `,
        )}
      &lt;/ol&gt;
    `;
  }
}

customElements.define('todo-list', TodoList);</code></pre><p>The styles we define here only apply to our element. This is because we're using Shadow DOM. Lit-element doesn't need to do any extra work. This means we can write simple CSS selectors, and we don't need to worry about causing conflicts with styles defined elsewhere in the page.</p><aside class="notice">
<code>:host</code> is a special selector, which selects the host of the shadow root that these styles are associated with. In our case that's our own custom element.
</aside><details>
  <summary>View final result</summary>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;todo-app&gt;&lt;/todo-app&gt;

    &lt;script type="module"&gt;
      import { LitElement, html, css } from 'lit';

      class TodoList extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        static get styles() {
          return css`
            :host {
              color: blue;
            }

            ul {
              list-style: none;
              padding: 0;
            }

            button {
              background-color: transparent;
              border: none;
            }
          `;
        }

        render() {
          if (!this.todos) {
            return html``;
          }

          return html`
            &lt;ol&gt;
              ${this.todos.map(
                todo =&gt; html`
                  &lt;li&gt;
                    &lt;input
                      type="checkbox"
                      .checked=${todo.finished}
                      @change=${e =&gt; this._changeTodoFinished(e, todo)}
                    /&gt;
                    ${todo.text}
                    &lt;button @click=${() =&gt; this._removeTodo(todo)}&gt;X&lt;/button&gt;
                  &lt;/li&gt;
                `,
              )}
            &lt;/ol&gt;
          `;
        }

        _changeTodoFinished(e, changedTodo) {
          const eventDetails = { changedTodo, finished: e.target.checked };
          this.dispatchEvent(new CustomEvent('change-todo-finished', { detail: eventDetails }));
        }

        _removeTodo(item) {
          this.dispatchEvent(new CustomEvent('remove-todo', { detail: item }));
        }
      }

      customElements.define('todo-list', TodoList);

      const author = 'open-wc';
      const homepage = 'https://open-wc.org/';
      const footerTemplate = html`
        &lt;footer&gt;Made with love by &lt;a href="${homepage}"&gt;${author}&lt;/a&gt;&lt;/footer&gt;
      `;

      class TodoApp extends LitElement {
        static get properties() {
          return {
            todos: { type: Array },
          };
        }

        constructor() {
          super();
          this.todos = [
            { text: 'Do A', finished: true },
            { text: 'Do B', finished: false },
            { text: 'Do C', finished: false },
          ];
        }

        render() {
          const finishedCount = this.todos.filter(e =&gt; e.finished).length;
          const unfinishedCount = this.todos.length - finishedCount;

          return html`
            &lt;h1&gt;Todo app&lt;/h1&gt;

            &lt;input id="addTodoInput" placeholder="Name" /&gt;
            &lt;button @click=${this._addTodo}&gt;Add&lt;/button&gt;

            &lt;todo-list
              .todos=${this.todos}
              @change-todo-finished=${this._changeTodoFinished}
              @remove-todo=${this._removeTodo}
            &gt;&lt;/todo-list&gt;

            &lt;div&gt;Total finished: ${finishedCount}&lt;/div&gt;
            &lt;div&gt;Total unfinished: ${unfinishedCount}&lt;/div&gt;

            ${footerTemplate}
          `;
        }

        _addTodo() {
          const input = this.shadowRoot.getElementById('addTodoInput');
          const text = input.value;
          input.value = '';

          this.todos = [...this.todos, { text, finished: false }];
        }

        _removeTodo(e) {
          this.todos = this.todos.filter(todo =&gt; todo !== e.detail);
        }

        _changeTodoFinished(e) {
          const { changedTodo, finished } = e.detail;

          this.todos = this.todos.map(todo =&gt; {
            if (todo !== changedTodo) {
              return todo;
            }
            return { ...changedTodo, finished };
          });
        }
      }

      customElements.define('todo-app', TodoApp);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>

    </google-codelab-step>

    <google-codelab-step label="Wrapping up">

    <p>And that's it! We've gone through the basics of lit-element and lit-html. Hopefully from here onwards you will be able to move forward working with lit-element and lit-html with confidence.</p><p>If you're eager to learn more, you can take a look at the following resources:</p><ul>
<li><a href="https://lit.dev/docs/libraries/standalone-templates/">lit-html official docs</a></li>
<li><a href="https://lit.dev/docs/api/LitElement/">lit-element official docs</a></li>
<li><a href="https://open-wc.org/guides/developing-components/code-examples/">open-wc code samples</a></li>
<li><a href="https://open-wc.org/guides/tools/ide/">IDE help</a></li>
</ul><p>To get started with your own project we recommend using open-wc's project scaffolding, it's easy to set it up using this command:</p><pre><code class="language-bash">npm init @open-wc</code></pre>

    </google-codelab-step>


      </google-codelab>

      <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
      <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
      <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
      <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

    </body>
    </html>
